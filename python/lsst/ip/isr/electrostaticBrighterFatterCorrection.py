# This file is part of ip_isr.
#
# Developed for the LSST Data Management System.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
"""Brighter Fatter Kernel calibration definition."""


__all__ = ['ElectrostaticBrighterFatter']


import numpy as np
from astropy.table import Table

from . import IsrCalib


class ElectrostaticBrighterFatter(IsrCalib):
    """Calibration of brighter-fatter kernels for an instrument.

    ampKernels are the kernels for each amplifier in a detector, as
    generated by having ``level == 'AMP'``.

    detectorKernel is the kernel generated for a detector as a
    whole, as generated by having ``level == 'DETECTOR'``.

    makeDetectorKernelFromAmpwiseKernels is a method to generate the
    kernel for a detector, constructed by averaging together the
    ampwise kernels in the detector.  The existing application code is
    only defined for kernels with ``level == 'DETECTOR'``, so this method
    is used if the supplied kernel was built with ``level == 'AMP'``.

    Parameters
    ----------
    camera : `lsst.afw.cameraGeom.Camera`
        Camera describing detector geometry.
    level : `str`
        Level the kernels will be generated for.
    log : `logging.Logger`, optional
        Log to write messages to.
    **kwargs :
        Parameters to pass to parent constructor.

    Notes
    -----
    Version 1.1 adds the `expIdMask` property, and substitutes
    `means` and `variances` for `rawMeans` and `rawVariances`
    from the PTC dataset.

    inputRange : `int`
        The size of the input aMatrix shape in each dimension.
    fitRange : `int`
        The size of the input aMatrix shape in each dimension that is
        used for fitting the electrostatic model. Must be less than or
        equal to inputRange.
    badAmps : `list`, [`str`]
        List of bad amplifiers names.
    gain : `dict`, [`str`,`float`]
        Dictionary keyed by amp names containing the gains inherited
        from the inputPTC.
    aMatrix : `numpy.ndarray`
        The average aMatrix inherited from the inputPTC's good amplifiers.
    aMatrixSigma : `numpy.ndarray`
        The uncertainty matrix used to weight the fit.
    aMatrixModel : `numpy.ndarray`
        The modeled aMatrix based on the electrostatic fit parameters.
    aMatrixSum : `float`
        The sum of the symmetrized aMatrix.
    aMatrixModelSum : `float`
        The sum of the symmetrized aMatrixModel.
    modelNormalization : `numpy.ndarray`
        A two element array of the multiplicative and additive
        normalization to the aMatrixModel.
    fitMask : `numpy.ndarray`, [`bool`]
        Array of shape like aMatrix containing the mask indicating which
        elements of the input aMatrix were used to fit the electrostatic
        model.
    fitParamNames : `list`, [`str`]
        List of all the parameter names in the electrostatic fit.
    freeFitParamNames : `list`, [`str`]
        List of the parameter names that were allowed to vary during
        the electrostatic fit.
    fitParams : `dict`, [`str`, `float`]
        Dictionary containing each named parameter and its final
        fitted value.
    fitParamErrors : `dict`, [`str`, `float`]
        Dictionary containing each named parameter and its
        estimated fitting error.
    fitChi2 : `float`
        The computed chi squared between the data and the
        final model.
    fitReducedChi2 : `float`
        The computed reduced chi squared between the data
        and the final model.
    fitParamCovMatrix : `numpy.ndarray`]
        The estimated covariance matrix between all fit parameters.
    ath : `numpy.ndarray`
        something...
    athMinusBeta : `numpy.ndarray`
        something...
    aN : `numpy.ndarray`
        Array of shape (fitRange, fitRange) containing the
        computed `North` component of the pixel boundary shift.
    aS : `numpy.ndarray`
        Array of shape (fitRange, fitRange) containing the
        computed `South` component of the pixel boundary shift.
    aE : `numpy.ndarray`
        Array of shape (fitRange, fitRange) containing the
        computed `East` component of the pixel boundary shift.
    aW : `numpy.ndarray`
        Array of shape (fitRange, fitRange) containing the
        computed `West` component of the pixel boundary shift.
    """
    _OBSTYPE = 'ebf'
    _SCHEMA = 'Brighter-fatter electrostatic correction model'
    _VERSION = 1.0

    def __init__(self, camera=None, inputRange=1, fitRange=None, **kwargs):
        """
        Filename  refers to an input tuple that contains the
        boundary shifts for one electron. This file is produced by an
        electrostatic fit to data extracted from flat-field statistics,
        implemented in https://gitlab.in2p3.fr/astier/bfptc/tools/fit_cov.py
        """
        self.inputRange = inputRange
        if fitRange is None:
            self.fitRange = inputRange
        else:
            self.fitRange = fitRange
        self.badAmps = list()
        self.gain = dict()
        self.aMatrix = np.full((inputRange, inputRange), np.nan)
        self.aMatrixSigma = np.full((inputRange, inputRange), np.nan)
        self.aMatrixModel = np.full((fitRange, fitRange), np.nan)
        self.aMatrixSum = np.nan
        self.aMatrixModelSum = np.nan
        self.modelNormalization = np.array([np.nan, np.nan])
        self.fitMask = np.full((inputRange, inputRange), np.nan)
        self.fitParamNames = list()
        self.freeFitParamNames = list()
        self.fitParams = dict()
        self.fitParamErrors = dict()
        self.fitChi2 = np.nan
        self.fitReducedChi2 = np.nan
        self.fitParamCovMatrix = np.array([])
        self.ath = np.full((fitRange, fitRange), np.nan)
        self.athMinusBeta = np.full((fitRange, fitRange), np.nan)
        self.aN = np.full((fitRange, fitRange), np.nan)
        self.aS = np.full((fitRange, fitRange), np.nan)
        self.aE = np.full((fitRange, fitRange), np.nan)
        self.aW = np.full((fitRange, fitRange), np.nan)

        super().__init__(**kwargs)

        if camera:
            self.initFromCamera(camera, detectorId=kwargs.get('detectorId', None))

        self.requiredAttributes.update([
            'inputRange', 'fitRange', 'badAmps', 'gain', 'aMatrix',
            'aMatrixSigma', 'aMatrixModel', 'aMatrixSum', 'aMatrixModelSum',
            'modelNormalization', 'fitMask', 'fitParamNames',
            'freeFitParamNames', 'fitParams', 'fitParamErrors', 'fitChi2',
            'fitReducedChi2', 'fitParamCovMatrix', 'ath', 'athMinusBeta',
            'aN', 'aS', 'aE', 'aW',
        ])

    def updateMetadata(self, setDate=False, **kwargs):
        """Update calibration metadata.

        This calls the base class's method after ensuring the required
        calibration keywords will be saved.

        Parameters
        ----------
        setDate : `bool`, optional
            Update the CALIBDATE fields in the metadata to the current
            time. Defaults to False.
        kwargs :
            Other keyword parameters to set in the metadata.
        """
        kwargs['INPUT_RANGE'] = self.inputRange
        kwargs['FIT_RANGE'] = self.fitRange

        super().updateMetadata(setDate=setDate, **kwargs)

    def initFromCamera(self, camera, detectorId=None):
        """Initialize kernel structure from camera.

        Parameters
        ----------
        camera : `lsst.afw.cameraGeom.Camera`
            Camera to use to define geometry.
        detectorId : `int`, optional
            Index of the detector to generate.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            The initialized calibration.

        Raises
        ------
        RuntimeError
            Raised if no detectorId is supplied for a calibration with
            ``level='AMP'``.
        """
        self._instrument = camera.getName()

        if detectorId is not None:
            detector = camera[detectorId]
            self._detectorId = detectorId
            self._detectorName = detector.getName()
            self._detectorSerial = detector.getSerial()

        return self

    @classmethod
    def fromDict(cls, dictionary):
        """Construct a calibration from a dictionary of properties.

        Parameters
        ----------
        dictionary : `dict`
            Dictionary of properties.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            Constructed calibration.

        Raises
        ------
        RuntimeError
            Raised if the supplied dictionary is for a different
            calibration.
            Raised if the version of the supplied dictionary is 1.0.
        """
        calib = cls()

        if calib._OBSTYPE != (found := dictionary['metadata']['OBSTYPE']):
            raise RuntimeError(f"Incorrect brighter-fatter calibration supplied.  Expected {calib._OBSTYPE}, "
                               f"found {found}")
        calib.setMetadata(dictionary['metadata'])
        calib.calibInfoFromDict(dictionary)

        for ampName in dictionary['ampNames']:
            calib.ampNames.append(ampName)
            calib.gain[ampName] = float(dictionary['gain'][ampName])

        inputRange = dictionary['inputRange']
        fitRange = dictionary['fitRange']
        calib.inputRange = inputRange
        calib.fitRange = fitRange
        calib.badAmps = dictionary['badAmps']
        calib.fitParamNames = dictionary['fitParamNames']
        calib.freeFitParamNames = dictionary['freeFitParamNames']

        calib.aMatrix[ampName] = np.array(
            dictionary['aMatrix'][ampName],
            dtype=np.float64,
        ).reshape(inputRange, inputRange)
        calib.aMatrixSigma[ampName] = np.array(
            dictionary['aMatrixSigma'][ampName],
            dtype=np.float64,
        ).reshape(inputRange, inputRange)
        calib.aMatrixModel[ampName] = np.array(
            dictionary['aMatrixSigma'][ampName],
            dtype=np.float64,
        ).reshape(fitRange, fitRange)
        calib.aMatrixSum[ampName] = float(dictionary['aMatrixSum'][ampName])
        calib.aMatrixModelSum[ampName] = float(dictionary['aMatrixModelSum'][ampName])
        calib.modelNormalization[ampName] = np.array(
            dictionary['modelNormalization'][ampName],
            dtype=np.float64,
        )
        calib.fitMask[ampName] = np.array(dictionary['fitMask'][ampName])
        calib.fitParams[ampName] = {n: float(v) for n, v in dictionary['fitParams'][ampName]}
        calib.fitParamErrors[ampName] = {n: float(v) for n, v in dictionary['fitParamErrors'][ampName]}
        calib.fitChi2[ampName] = float(dictionary['fitChi2'][ampName])
        calib.fitReducedChi2[ampName] = float(dictionary['fitReducedChi2'][ampName])
        calib.fitParamCovMatrix[ampName] = np.array(
            dictionary['fitParamCovMatrix'][ampName],
            dtype=np.float64,
        ).reshape(fitRange, fitRange)
        calib.ath[ampName] = np.array(
            dictionary['ath'][ampName],
            dtype=np.float64,
        ).reshape(fitRange, fitRange)
        calib.athMinusBeta[ampName] = np.array(
            dictionary['athMinusBeta'][ampName],
            dtype=np.float64,
        ).reshape(fitRange, fitRange)
        calib.aN[ampName] = np.array(
            dictionary['aN'][ampName],
            dtype=np.float64,
        ).reshape(fitRange, fitRange)
        calib.aS[ampName] = np.array(
            dictionary['aS'][ampName],
            dtype=np.float64,
        ).reshape(fitRange, fitRange)
        calib.aE[ampName] = np.array(
            dictionary['aE'][ampName],
            dtype=np.float64,
        ).reshape(fitRange, fitRange)
        calib.aW[ampName] = np.array(
            dictionary['aW'][ampName],
            dtype=np.float64,
        ).reshape(fitRange, fitRange)

        calib.updateMetadata()
        return calib

    def toDict(self):
        """Return a dictionary containing the calibration properties.

        The dictionary should be able to be round-tripped through
        `fromDict`.

        Returns
        -------
        dictionary : `dict`
            Dictionary of properties.
        """
        self.updateMetadata()

        outDict = dict()
        metadata = self.getMetadata()
        outDict['metadata'] = metadata

        outDict['ampNames'] = self.ampNames
        outDict['inputRange'] = self.inputRange
        outDict['fitRange'] = self.fitRange
        outDict['badAmps'] = self.badAmps
        outDict['fitParamNames'] = self.fitParamNames
        outDict['freeFitParamNames'] = self.freeFitParamNames
        outDict['gain'] = self.gain
        outDict['aMatrix'] = self.aMatrix.ravel().tolist()
        outDict['aMatrixSigma'] = self.aMatrixSigma.ravel().tolist()
        outDict['aMatrixModel'] = self.aMatrixModel.ravel().tolist()
        outDict['aMatrixSum'] = self.aMatrixSum
        outDict['aMatrixModelSum'] = self.aMatrixModelSum
        outDict['aMatrixModel'] = self.aMatrixModel.ravel().tolist()
        outDict['modelNormalization'] = self.modelNormalization.tolist()
        outDict['fitMask'] = self.fitMask.ravel().tolist()
        outDict['fitParams'] = self.fitParams.tolist()
        outDict['fitParamErrors'] = self.fitParamErrors.tolist()
        outDict['fitChi2'] = self.fitChi2
        outDict['fitReducedChi2'] = self.fitReducedChi2
        outDict['ath'] = self.ath.ravel().tolist()
        outDict['athMinusBeta'] = self.athMinusBeta.ravel().tolist()
        outDict['aN'] = self.aN.ravel().tolist()
        outDict['aS'] = self.aS.ravel().tolist()
        outDict['sE'] = self.aE.ravel().tolist()
        outDict['sW'] = self.aW.ravel().tolist()

        return outDict

    @classmethod
    def fromTable(cls, tableList):
        """Construct calibration from a list of tables.

        This method uses the `fromDict` method to create the
        calibration, after constructing an appropriate dictionary from
        the input tables.

        Parameters
        ----------
        tableList : `list` [`astropy.table.Table`]
            List of tables to use to construct the brighter-fatter
            calibration.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            The calibration defined in the tables.
        """
        ampTable = tableList[0]

        metadata = ampTable.meta
        calibVersion = metadata['ebf_VERSION']

        # Initialize inDict with all expected keys
        # and empty values of the corresponding type
        inDict = dict()
        inDict['metadata'] = metadata
        inDict['metadata'] = None
        inDict['ampNames'] = []
        inDict['inputRange'] = None
        inDict['fitRange'] = None
        inDict['badAmps'] = []
        inDict['fitParamNames'] = []
        inDict['freeFitParamNames'] = []
        inDict['gain'] = dict()
        inDict['aMatrix'] = []
        inDict['aMatrixSigma'] = []
        inDict['aMatrixModel'] = []
        inDict['aMatrixSum'] = None
        inDict['aMatrixModelSum'] = None
        inDict['modelNormalization'] = []
        inDict['fitMask'] = []
        inDict['fitParams'] = []
        inDict['fitParamErrors'] = []
        inDict['fitChi2'] = None
        inDict['fitReducedChi2'] = None
        inDict['fitParamCovMatrix'] = []
        inDict['ath'] = []
        inDict['athMinusBeta'] = []
        inDict['aN'] = []
        inDict['aS'] = []
        inDict['aE'] = []
        inDict['aW'] = []

        if not calibVersion == 1.0:
            cls().log.warning("Unkown version found for "
                              f"ElectrostaticBrighterFatter: {calibVersion}. ")
        for record in ampTable:
            ampName = record['AMPLIFIER_NAME']
            inDict['ampNames'].append(ampName)
            inDict['inputRange'] = record['INPUT_RANGE'][0]
            inDict['fitRange'] = record['FIT_RANGE']
            inDict['badAmps'] = record['BAD_AMPS']
            inDict['gain'][ampName] = record['GAIN']
            inDict['aMatrix'] = record['A_MATRIX']
            inDict['aMatrixSigma'] = record['A_MATRIX_SIGMA']
            inDict['aMatrixModel'] = record['A_MATRIX_MODEL']
            inDict['aMatrixSum'] = record['A_MATRIX_SUM']
            inDict['aMatrixModelSum'] = record['A_MATRIX_MODEL_SUM']
            inDict['modelNormalization'] = record['MODEL_NORMALIZATION']
            inDict['fitMask'] = record['FIT_MASK']
            inDict['fitParams'] = record['FIT_PARAMS']
            inDict['fitParamErrors'] = record['FIT_PARAM_ERRORS']
            inDict['fitChi2'] = record['FIT_CHI2']
            inDict['fitReducedChi2'] = record['FIT_REDUCED_CHI2']
            inDict['fitParamCovMatrix'] = record['FIT_PARAM_COV_MATRIX']
            inDict['ath'] = record['ATH']
            inDict['athMinusBeta'] = record['ATH_MINUS_BETA']
            inDict['aN'] = record['A_N']
            inDict['aS'] = record['A_S']
            inDict['aE'] = record['A_E']
            inDict['aW'] = record['A_W']
            # Check for newer versions, but there are none...

        return cls.fromDict(inDict)

    def toTable(self):
        """Construct a list of tables containing the information in this
        calibration.

        The list of tables should create an identical calibration
        after being passed to this class's fromTable method.

        Returns
        -------
        tableList : `list` [`lsst.afw.table.Table`]
            List of tables containing the crosstalk calibration
            information.

        """
        tableList = []
        self.updateMetadata()

        catalogList = []
        for ampName in self.ampNames:
            ampDict = {
                'AMPLIFIER': ampName,
                'INPUT_RANGE': self.inputRange,
                'FIT_RANGE': self.fitRange,
                'BAD_AMPS': self.badAmps,
                'GAIN': self.gain.get(ampName),
                'A_MATRIX': self.aMatrix.ravel(),
                'A_MATRIX_SIGMA': self.aMatrixSigma.ravel(),
                'A_MATRIX_MODEL': self.aMatrixModel.ravel(),
                'A_MATRIX_SUM': self.aMatrixSum.get(ampName),
                'A_MATRIX_MODEL_SUM': self.aMatrixModelSum,
                'MODEL_NORMALIZATION': self.modelNormalization.ravel(),
                'FIT_MASK': self.fitMask.ravel(),
                'FIT_PARAM_NAMES': self.fitParamNames.ravel(),
                'FREE_FIT_PARAM_NAMES': self.freeFitParamNames.ravel(),
                'FIT_PARAMS': self.fitParams.ravel(),
                'FIT_PARAM_ERRORS': self.fitParamErrors.ravel(),
                'FIT_CHI2': self.fitChi2,
                'FIT_REDUCED_CHI2': self.fitReducedChi2,
                'FIT_PARAM_COV_MATRIX': self.fitParamCovMatrix.ravel(),
                'ATH': self.ath.ravel(),
                'ATH_MINUS_BETA': self.athMinusBeta.ravel(),
                'A_N': self.aN.ravel(),
                'A_S': self.aS.ravel(),
                'A_E': self.aE.ravel(),
                'A_W': self.aW.ravel(),
            }

            catalogList.append(ampDict)

        catalog = Table(catalogList)

        inMeta = self.getMetadata().toDict()
        outMeta = {k: v for k, v in inMeta.items() if v is not None}
        outMeta.update({k: "" for k, v in inMeta.items() if v is None})
        catalog.meta = outMeta
        tableList.append(catalog)

        return tableList
