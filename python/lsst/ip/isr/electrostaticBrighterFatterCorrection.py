# This file is part of ip_isr.
#
# Developed for the LSST Data Management System.
# This product includes software developed by the LSST Project
# (https://www.lsst.org).
# See the COPYRIGHT file at the top-level directory of this distribution
# for details of code ownership.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
"""Brighter Fatter Kernel calibration definition."""


__all__ = ['ElectrostaticBrighterFatterCalibration']


import numpy as np
from astropy.table import Table

from . import IsrCalib


class ElectrostaticBrighterFatterCalibration(IsrCalib):
    """Calibration of brighter-fatter kernels for an instrument.

    ampKernels are the kernels for each amplifier in a detector, as
    generated by having ``level == 'AMP'``.

    detectorKernel is the kernel generated for a detector as a
    whole, as generated by having ``level == 'DETECTOR'``.

    makeDetectorKernelFromAmpwiseKernels is a method to generate the
    kernel for a detector, constructed by averaging together the
    ampwise kernels in the detector.  The existing application code is
    only defined for kernels with ``level == 'DETECTOR'``, so this method
    is used if the supplied kernel was built with ``level == 'AMP'``.

    Parameters
    ----------
    camera : `lsst.afw.cameraGeom.Camera`
        Camera describing detector geometry.
    level : `str`
        Level the kernels will be generated for.
    log : `logging.Logger`, optional
        Log to write messages to.
    **kwargs :
        Parameters to pass to parent constructor.

    Notes
    -----
    Version 1.1 adds the `expIdMask` property, and substitutes
    `means` and `variances` for `rawMeans` and `rawVariances`
    from the PTC dataset.

    inputRange : `int`
        The size of the input aMatrix shape in each dimension.
    fitRange : `int`
        The size of the input aMatrix shape in each dimension that is
        used for fitting the electrostatic model. Must be less than or
        equal to inputRange.
    badAmps : `list`, [`str`]
        List of bad amplifiers names.
    gain : `dict`, [`str`,`float`]
        Dictionary keyed by amp names containing the gains inherited
        from the inputPTC.
    aMatrix : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing the aMatrix inherited
        from the inputPTC
    aMatrixSigma : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing the estimated uncertainty
        used to weight the residuals in the electrostatic fit.
    aMatrixModel : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing the modeled aMatrix
        based on the electrostatic fit parameters.
    aMatrixSum : `dict`, [`str`,`float`]
        Dictionary keyed by amp names containing the sum of the aMatrix.
    aMatrixModelSum : `dict`, [`str`,`float`]
        Dictionary keyed by amp names containing the sum of the aMatrixModel.
    modelNormalization : `dict`, [`str`,`numpy.ndarray`]
        Dictionary keyed by amp names containing a two element array of the
        multiplicative and additive normalization to the aMatrixModel.
    fitMask : `dict`, [`str`,`numpy.ndarray`]
        Dictionary keyed by amp names containing the mask indicated which
        elements of the input aMatrix were used to fit the electrostatic
        model. It will have shape (inputRange, inputRange).
    fitParamNames : `list`, [`str`]
        List of all the parameter names in the electrostatic fit.
    freeFitParamNames : `list`, [`str`]
        List of the parameter names that were allowed to vary during
        the electrostatic fit.
    fitParams : `dict`, [`str`, `float`]
        Dictionary keyed by amp names containing each named parameter
        and its final fitted value.
    fitParamErrors : `dict`, [`str`, `float`]
        Dictionary keyed by amp names containing each named parameter
        and its estimated fitting error.
    fitChi2 : `dict`, [`str`, `float`]
        Dictionary keyed by amp names containing the computed chi squared
        between the data and the final model.
    fitReducedChi2 : `dict`, [`str`, `float`]
        Dictionary keyed by amp names containing the computed reduced
        chi squared between the data and the final model.
    fitParamCovMatrix : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing the estimated covariance
        matrix between all fit parameters.
    ath : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing something...
    athMinusBeta : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing something...
    aN : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing the computed `North`
        component of the pixel boundary shift.
    aS : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing the computed `South`
        component of the pixel boundary shift.
    aE : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing the computed `East`
        component of the pixel boundary shift.
    aW : `dict`, [`str`, `numpy.ndarray`]
        Dictionary keyed by amp names containing the computed `West`
        component of the pixel boundary shift.
    """
    _OBSTYPE = 'ebf'
    _SCHEMA = 'Brighter-fatter electrostatic correction model'
    _VERSION = 1.0

    def __init__(self, camera=None, inputRange=1, fitRange=None, **kwargs):
        """
        Filename  refers to an input tuple that contains the
        boundary shifts for one electron. This file is produced by an
        electrostatic fit to data extracted from flat-field statistics,
        implemented in https://gitlab.in2p3.fr/astier/bfptc/tools/fit_cov.py
        """
        self.inputRange = inputRange
        if fitRange is None:
            self.fitRange = inputRange
        else:
            self.fitRange = fitRange
        self.badAmps = list()
        self.gain = dict()
        self.aMatrix = dict()
        self.aMatrixSigma = dict()
        self.aMatrixModel = dict()
        self.aMatrixSum = dict()
        self.aMatrixModelSum = dict()
        self.modelNormalization = dict()
        self.fitMask = dict()
        self.fitParamNames = list()
        self.freeFitParamNames = list()
        self.fitParams = dict()
        self.fitParamErrors = dict()
        self.fitChi2 = dict()
        self.fitReducedChi2 = dict()
        self.fitParamCovMatrix = dict()
        self.ath = dict()
        self.athMinusBeta = dict()
        self.aN = dict()
        self.aS = dict()
        self.aE = dict()
        self.aW = dict()

        super().__init__(**kwargs)

        if camera:
            self.initFromCamera(camera, detectorId=kwargs.get('detectorId', None))

        self.requiredAttributes.update([
            'inputRange', 'fitRange', 'badAmps', 'gain', 'aMatrix',
            'aMatrixSigma', 'aMatrixModel', 'aMatrixSum', 'aMatrixModelSum',
            'modelNormalization', 'fitMask', 'fitParamNames',
            'freeFitParamNames', 'fitParams', 'fitParamErrors', 'fitChi2',
            'fitReducedChi2', 'fitParamCovMatrix', 'ath', 'athMinusBeta',
            'aN', 'aS', 'aE', 'aW',
        ])

    def updateMetadata(self, setDate=False, **kwargs):
        """Update calibration metadata.

        This calls the base class's method after ensuring the required
        calibration keywords will be saved.

        Parameters
        ----------
        setDate : `bool`, optional
            Update the CALIBDATE fields in the metadata to the current
            time. Defaults to False.
        kwargs :
            Other keyword parameters to set in the metadata.
        """
        kwargs['INPUT_RANGE'] = self.inputRange
        kwargs['FIT_RANGE'] = self.fitRange

        super().updateMetadata(setDate=setDate, **kwargs)

    def initFromCamera(self, camera, detectorId=None):
        """Initialize kernel structure from camera.

        Parameters
        ----------
        camera : `lsst.afw.cameraGeom.Camera`
            Camera to use to define geometry.
        detectorId : `int`, optional
            Index of the detector to generate.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            The initialized calibration.

        Raises
        ------
        RuntimeError
            Raised if no detectorId is supplied for a calibration with
            ``level='AMP'``.
        """
        self._instrument = camera.getName()

        if detectorId is not None:
            detector = camera[detectorId]
            self._detectorId = detectorId
            self._detectorName = detector.getName()
            self._detectorSerial = detector.getSerial()

        return self

    @classmethod
    def fromDict(cls, dictionary):
        """Construct a calibration from a dictionary of properties.

        Parameters
        ----------
        dictionary : `dict`
            Dictionary of properties.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            Constructed calibration.

        Raises
        ------
        RuntimeError
            Raised if the supplied dictionary is for a different
            calibration.
            Raised if the version of the supplied dictionary is 1.0.
        """
        calib = cls()

        if calib._OBSTYPE != (found := dictionary['metadata']['OBSTYPE']):
            raise RuntimeError(f"Incorrect brighter-fatter calibration supplied.  Expected {calib._OBSTYPE}, "
                               f"found {found}")
        calib.setMetadata(dictionary['metadata'])
        calib.calibInfoFromDict(dictionary)

        inputRange = dictionary['inputRange']
        fitRange = dictionary['fitRange']
        calib.inputRange = inputRange
        calib.fitRange = fitRange
        calib.badAmps = dictionary['badAmps']
        calib.fitParamNames = dictionary['fitParamNames']
        calib.freeFitParamNames = dictionary['freeFitParamNames']

        for ampName in dictionary['ampNames']:
            calib.ampNames.append(ampName)
            calib.gain[ampName] = float(dictionary['gain'][ampName])
            calib.aMatrix[ampName] = np.array(
                dictionary['aMatrix'][ampName],
                dtype=np.float64,
            ).reshape(inputRange, inputRange)
            calib.aMatrixSigma[ampName] = np.array(
                dictionary['aMatrixSigma'][ampName],
                dtype=np.float64,
            ).reshape(inputRange, inputRange)
            calib.aMatrixModel[ampName] = np.array(
                dictionary['aMatrixSigma'][ampName],
                dtype=np.float64,
            ).reshape(fitRange, fitRange)
            calib.aMatrixSum[ampName] = float(dictionary['aMatrixSum'][ampName])
            calib.aMatrixModelSum[ampName] = float(dictionary['aMatrixModelSum'][ampName])
            calib.modelNormalization[ampName] = np.array(
                dictionary['modelNormalization'][ampName],
                dtype=np.float64,
            )
            calib.fitMask[ampName] = np.array(dictionary['fitMask'][ampName])
            calib.fitParams[ampName] = {n: float(v) for n, v in dictionary['fitParams'][ampName]}
            calib.fitParamErrors[ampName] = {n: float(v) for n, v in dictionary['fitParamErrors'][ampName]}
            calib.fitChi2[ampName] = float(dictionary['fitChi2'][ampName])
            calib.fitReducedChi2[ampName] = float(dictionary['fitReducedChi2'][ampName])
            calib.fitParamCovMatrix[ampName] = np.array(
                dictionary['fitParamCovMatrix'][ampName],
                dtype=np.float64,
            ).reshape(fitRange, fitRange)
            calib.ath[ampName] = np.array(
                dictionary['ath'][ampName],
                dtype=np.float64,
            ).reshape(fitRange, fitRange)
            calib.athMinusBeta[ampName] = np.array(
                dictionary['athMinusBeta'][ampName],
                dtype=np.float64,
            ).reshape(fitRange, fitRange)
            calib.aN[ampName] = np.array(
                dictionary['aN'][ampName],
                dtype=np.float64,
            ).reshape(fitRange, fitRange)
            calib.aS[ampName] = np.array(
                dictionary['aS'][ampName],
                dtype=np.float64,
            ).reshape(fitRange, fitRange)
            calib.aE[ampName] = np.array(
                dictionary['aE'][ampName],
                dtype=np.float64,
            ).reshape(fitRange, fitRange)
            calib.aW[ampName] = np.array(
                dictionary['aW'][ampName],
                dtype=np.float64,
            ).reshape(fitRange, fitRange)

        calib.updateMetadata()
        return calib

    def toDict(self):
        """Return a dictionary containing the calibration properties.

        The dictionary should be able to be round-tripped through
        `fromDict`.

        Returns
        -------
        dictionary : `dict`
            Dictionary of properties.
        """
        self.updateMetadata()

        outDict = dict()
        metadata = self.getMetadata()
        outDict['metadata'] = metadata

        def _dictOfArraysToDictOfLists(dictOfArrays):
            dictOfLists = dict()
            for key, value in dictOfArrays.items():
                dictOfLists[key] = value.ravel().tolist()

            return dictOfLists

        outDict['ampNames'] = self.ampNames
        outDict['inputRange'] = self.inputRange
        outDict['fitRange'] = self.fitRange
        outDict['badAmps'] = self.badAmps
        outDict['fitParamNames'] = self.fitParamNames
        outDict['freeFitParamNames'] = self.freeFitParamNames
        outDict['gain'] = self.gain
        outDict['aMatrix'] = _dictOfArraysToDictOfLists(self.aMatrix)
        outDict['aMatrixSigma'] = _dictOfArraysToDictOfLists(self.aMatrixSigma)
        outDict['aMatrixModel'] = _dictOfArraysToDictOfLists(self.aMatrixModel)
        outDict['aMatrixSum'] = self.aMatrixSum
        outDict['aMatrixModelSum'] = self.aMatrixModelSum
        outDict['aMatrixModel'] = _dictOfArraysToDictOfLists(self.aMatrixModel)
        outDict['modelNormalization'] = _dictOfArraysToDictOfLists(self.modelNormalization)
        outDict['fitMask'] = _dictOfArraysToDictOfLists(self.fitMask)
        outDict['fitParams'] = self.fitParams
        outDict['fitParamErrors'] = self.fitParamErrors
        outDict['fitChi2'] = self.fitChi2
        outDict['fitReducedChi2'] = self.fitReducedChi2
        outDict['ath'] = _dictOfArraysToDictOfLists(self.ath)
        outDict['athMinusBeta'] = _dictOfArraysToDictOfLists(self.athMinusBeta)
        outDict['aN'] = _dictOfArraysToDictOfLists(self.aN)
        outDict['aS'] = _dictOfArraysToDictOfLists(self.aS)
        outDict['sE'] = _dictOfArraysToDictOfLists(self.aE)
        outDict['sW'] = _dictOfArraysToDictOfLists(self.aW)

        return outDict

    @classmethod
    def fromTable(cls, tableList):
        """Construct calibration from a list of tables.

        This method uses the `fromDict` method to create the
        calibration, after constructing an appropriate dictionary from
        the input tables.

        Parameters
        ----------
        tableList : `list` [`astropy.table.Table`]
            List of tables to use to construct the brighter-fatter
            calibration.

        Returns
        -------
        calib : `lsst.ip.isr.BrighterFatterKernel`
            The calibration defined in the tables.
        """
        ampTable = tableList[0]

        metadata = ampTable.meta
        calibVersion = metadata['ebf_VERSION']

        # Initialize inDict with all expected keys
        # and empty values of the corresponding type
        inDict = dict()
        inDict['metadata'] = metadata
        inDict['metadata'] = None
        inDict['ampNames'] = []
        inDict['inputRange'] = None
        inDict['fitRange'] = None
        inDict['badAmps'] = []
        inDict['fitParamNames'] = []
        inDict['freeFitParamNames'] = []
        inDict['gain'] = dict()
        inDict['aMatrix'] = dict()
        inDict['aMatrixSigma'] = dict()
        inDict['aMatrixModel'] = dict()
        inDict['aMatrixSum'] = dict()
        inDict['aMatrixModelSum'] = dict()
        inDict['modelNormalization'] = dict()
        inDict['fitMask'] = dict()
        inDict['fitParams'] = dict()
        inDict['fitParamErrors'] = dict()
        inDict['fitChi2'] = dict()
        inDict['fitReducedChi2'] = dict()
        inDict['fitParamCovMatrix'] = dict()
        inDict['ath'] = dict()
        inDict['athMinusBeta'] = dict()
        inDict['aN'] = dict()
        inDict['aS'] = dict()
        inDict['aE'] = dict()
        inDict['aW'] = dict()

        if not calibVersion == 1.0:
            cls().log.warning("Unkown version found for "
                              f"ElectrostaticBrighterFatterCalibration: {calibVersion}. ")
        for record in ampTable:
            ampName = record['AMPLIFIER_NAME']
            inDict['ampNames'].append(ampName)
            inDict['inputRange'] = record['INPUT_RANGE'][0]
            inDict['fitRange'] = record['FIT_RANGE']
            inDict['badAmps'] = record['BAD_AMPS']
            inDict['gain'][ampName] = record['GAIN']
            inDict['aMatrix'][ampName] = record['A_MATRIX']
            inDict['aMatrixSigma'][ampName] = record['A_MATRIX_SIGMA']
            inDict['aMatrixModel'][ampName] = record['A_MATRIX_MODEL']
            inDict['aMatrixSum'][ampName] = record['A_MATRIX_SUM']
            inDict['aMatrixModelSum'][ampName] = record['A_MATRIX_MODEL_SUM']
            inDict['modelNormalization'][ampName] = record['MODEL_NORMALIZATION']
            inDict['fitMask'][ampName] = record['FIT_MASK']
            inDict['fitParams'][ampName] = record['FIT_PARAMS']
            inDict['fitParamErrors'][ampName] = record['FIT_PARAM_ERRORS']
            inDict['fitChi2'][ampName] = record['FIT_CHI2']
            inDict['fitReducedChi2'][ampName] = record['FIT_REDUCED_CHI2']
            inDict['fitParamCovMatrix'][ampName] = record['FIT_PARAM_COV_MATRIX']
            inDict['ath'][ampName] = record['ATH']
            inDict['athMinusBeta'][ampName] = record['ATH_MINUS_BETA']
            inDict['aN'][ampName] = record['A_N']
            inDict['aS'][ampName] = record['A_S']
            inDict['aE'][ampName] = record['A_E']
            inDict['aW'][ampName] = record['A_W']
            # Check for newer versions, but there are none...

        return cls.fromDict(inDict)

    def toTable(self):
        """Construct a list of tables containing the information in this
        calibration.

        The list of tables should create an identical calibration
        after being passed to this class's fromTable method.

        Returns
        -------
        tableList : `list` [`lsst.afw.table.Table`]
            List of tables containing the crosstalk calibration
            information.

        """
        tableList = []
        self.updateMetadata()

        catalogList = []
        for ampName in self.ampNames:
            ampDict = {
                'AMPLIFIER': ampName,
                'INPUT_RANGE': self.inputRange,
                'FIT_RANGE': self.fitRange,
                'BAD_AMPS': self.badAmps,
                'GAIN': self.gain.get(ampName),
                'A_MATRIX': (
                    self.aMatrix.get(ampName).ravel() if ampName in self.aMatrix else None
                ),
                'A_MATRIX_SIGMA': (
                    self.aMatrixSigma.get(ampName).ravel() if ampName in self.aMatrixSigma else None
                ),
                'A_MATRIX_MODEL': (
                    self.aMatrixModel.get(ampName).ravel() if ampName in self.aMatrixModel else None
                ),
                'A_MATRIX_SUM': self.aMatrixSum.get(ampName),
                'A_MATRIX_MODEL_SUM': self.aMatrixModelSum.get(ampName),
                'MODEL_NORMALIZATION': (
                    self.modelNormalization.get(ampName).ravel()
                    if ampName in self.modelNormalization else None
                ),
                'FIT_MASK': (
                    self.fitMask.get(ampName).ravel() if ampName in self.fitMask else None
                ),
                'FIT_PARAM_NAMES': (
                    self.fitParamNames.ravel() if ampName in self.fitParamNames else None
                ),
                'FREE_FIT_PARAM_NAMES': (
                    self.freeFitParamNames.ravel() if ampName in self.freeFitParamNames else None
                ),
                'FIT_PARAMS': (
                    self.fitParams.get(ampName).ravel() if ampName in self.fitParams else None
                ),
                'FIT_PARAM_ERRORS': (
                    self.fitParamErrors.get(ampName).ravel() if ampName in self.fitParamErrors else None
                ),
                'FIT_CHI2': self.fitChi2.get(ampName),
                'FIT_REDUCED_CHI2': self.fitReducedChi2.get(ampName),
                'FIT_PARAM_COV_MATRIX': (
                    self.fitParamCovMatrix.get(ampName).ravel()
                    if ampName in self.fitParamCovMatrix else None
                ),
                'ATH': (
                    self.ath.get(ampName).ravel() if ampName in self.ath else None
                ),
                'ATH_MINUS_BETA': (
                    self.athMinusBeta.get(ampName).ravel() if ampName in self.athMinusBeta else None
                ),
                'A_N': (
                    self.aN.get(ampName).ravel() if ampName in self.aN else None
                ),
                'A_S': (
                    self.aS.get(ampName).ravel() if ampName in self.aS else None
                ),
                'A_E': (
                    self.aE.get(ampName).ravel() if ampName in self.aE else None
                ),
                'A_W': (
                    self.aW.get(ampName).ravel() if ampName in self.aW else None
                ),
            }

            catalogList.append(ampDict)

        catalog = Table(catalogList)

        inMeta = self.getMetadata().toDict()
        outMeta = {k: v for k, v in inMeta.items() if v is not None}
        outMeta.update({k: "" for k, v in inMeta.items() if v is None})
        catalog.meta = outMeta
        tableList.append(catalog)

        return tableList
